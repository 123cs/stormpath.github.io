<h2 id="collectionresource">CollectionResource</h2><p>A <code>CollectionResource</code> is an object that represents a <a href="http://docs.stormpath.com/rest/product-guide/#collection-resources">Stormpath REST API Collection Resource</a>. It is itself a resource with its own properties, but it contains other REST resources.</p><p>Every collection resource has the following fields:</p><table class="table table-striped table-hover table-curved"><thead><tr><th>Field<th>Type<th>Description<th><tbody><tr><td><code>href</code><td><code>string</code><td>The fully qualified location URI of the Collection Resource.<tr><td><code>offset</code><td><code>integer</code><td>The zero-based starting index in the entire collection of the first item to return. The default value is 0. This is a <a href="http://docs.stormpath.com/rest/product-guide/#pagination">pagination</a>-specific attribute.<tr><td><code>limit</code><td><code>integer</code><td>The maximum number of collection items to return for a single request. Minimum value is 1. The maximum value is 100 and the default value is 25. This is a <a href="http://docs.stormpath.com/rest/product-guide/#pagination">pagination</a>-specific attribute.<tr><td><code>items</code><td><code>array</code><td>An array containing the current page of resources. The size of this array can be less than the requested limit. For example, if the limit requested is greater than the maximum allowed or if the response represents the final page in the total collection and the item count of the final page is less than the limit. This is a <a href="http://docs.stormpath.com/rest/product-guide/#pagination">pagination</a>-specific attribute.</table><p>Here is an example of a <code>CollectionResource</code>&#39;s JSON representation (in this case, a random <a href="tenant">Tenant</a>&#39;s collection of <a href="application">Application</a>s:</p><pre><code class="lang-javascript">{
  href: &#39;https://api.stormpath.com/v1/tenants/1X2vlZCo4vd8Ar6LD7UHjj/applications&#39;,
  offset: 0,
  limit: 100,
  size: 100,
  items: [
    { ... app0 name/value pairs ... },
    { ... app1 name/value pairs ... },
    ...,
    { ... app99 name/value pairs ... }
  }
}</code></pre><p><strong>Instantiation</strong></p><p>The Stormpath REST API already defines all available collections - you should never need to explicitly create a new CollectionResource instance. CollectionResource instances are returned automatically when requesting an existing REST API collection.</p><h4 id="-a-name-pagination-a-automatic-pagination"><a name="pagination"></a>Automatic Pagination</h4><p>If you request a collection directly from the REST API, and the collection is sufficiently large, the Stormpath REST API servers will not return all items within the collection in a single response. Instead, a technique known as <a href="http://docs.stormpath.com/rest/product-guide/#pagination">pagination</a> is used to break up the results into one or more of pages of data.</p><p>However, this is not something you need to worry about when using the Stormpath SDK for Node.js. If you call the <a href="collectionResource#each">each</a> method to iterate over the collection items, it will automatically paginate for you during iteration:</p><p>As iteration executes, if the <code>CollectionResource</code> encounters the end of a page of results, it will request the next page automatically, internalize the results, and those will be used to continue iteration. This simulates the entire collection being available in memory.</p><h5 id="disable-automatic-pagination">Disable Automatic Pagination</h5><p>If you do not prefer automatic pagination, you can just ignore this feature: don&#39;t call the <code>each</code> method and instead interact directly with the collection&#39;s <code>items</code> array.</p><p>Once you exhaust an <code>items</code> array, you will then be required request the collection&#39;s <code>href</code> and <a href="http://docs.stormpath.com/rest/product-guide/#pagination">pagination query parameters</a> to obtain further pages of data.</p><p><strong>Since</strong>: 0.1</p><hr><p><a name="forEach"></a> <a name="each"></a></p><h3 id="-span-class-member-method-span-each-iterator-callback-"><span class="member">method</span> each(iterator, callback)</h3><p>Applies the function <code>iterator</code> to each item in <code>collection</code> resource, in parallel. The <code>iterator</code> is called with an item from the list, and a callback for when it has finished. If the <code>iterator</code> passes an error to its <code>callback</code>, the main <code>callback</code> (for the <code>each</code> function) is immediately called with the error.</p><p>Note, that since this function applies <code>iterator</code> to each item in parallel, there is no guarantee that the iterator functions will complete in order.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><h4 id="usage">Usage</h4><pre><code class="lang-javascript">// assuming applications is a collection resource

function iterator(application, cb) {
  console.log(application);
  cb();
}

applications.each(iterator, function (err) {
  // if any of the iterator calls produced an error, err would equal that error
});</code></pre><h4 id="parameters">Parameters</h4><table class="table table-striped table-hover table-curved"><thead><tr><th>Parameter<th>Type<th>Presence<th>Description<th><tbody><tr><td><code>iterator(item, callback)</code><td><code>function</code><td><strong>required</strong><td>A function to apply to each item in <code>arr</code>. The iterator is passed a <code>callback(err)</code> which must be called once it has completed. If no error has occurred, the <code>callback</code> should be run without arguments or with an explicit <code>null</code> argument.<tr><td><code>callback(err)</code><td><code>function</code><td><strong>required</strong><td>A callback which is called when all <code>iterator</code> functions have finished, or an error occurs.</table><hr><p><a name="forEachSeries"></a> <a name="eachSeries"></a></p><h3 id="-span-class-member-method-span-eachseries-iterator-callback-"><span class="member">method</span> eachSeries(iterator, callback)</h3><p>The same as <a href="collectionResource#each"><code>each</code></a>, only <code>iterator</code> is applied to each item in <code>collection</code> resource in series. The next <code>iterator</code> is only called once the current one has completed. This means the <code>iterator</code> functions will complete in order.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><hr><p><a name="forEachLimit"></a> <a name="eachLimit"></a></p><h3 id="-span-class-member-method-span-eachlimit-limit-iterator-callback-"><span class="member">method</span> eachLimit(limit, iterator, callback)</h3><p>The same as <a href="collectionResource#each"><code>each</code></a>, only no more than <code>limit</code> <code>iterator</code>s will be simultaneously running at any time.</p><p>Note that the items in <code>collection</code> resource are not processed in batches, so there is no guarantee that the first <code>limit</code> <code>iterator</code> functions will complete before any others are started.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><h4 id="usage">Usage</h4><pre><code class="lang-javascript">// assuming applications is a collection resource

function processApplication(application, cb) {
  //do some work with application
  cb();
}

async.eachLimit(20, processApplication, function(err) {
  // if any of the saves produced an error, err would equal that error
});</code></pre><h4 id="parameters">Parameters</h4><table class="table table-striped table-hover table-curved"><thead><tr><th>Parameter<th>Type<th>Presence<th>Description<th><tbody><tr><td><code>limit</code><td><code>Number</code><td><strong>required</strong><td>The maximum number of <code>iterator</code>s to run at any time.<tbody><tr><td><code>iterator(item, callback)</code><td><code>function</code><td><strong>required</strong><td>A function to apply to each item in <code>arr</code>. The iterator is passed a <code>callback(err)</code> which must be called once it has completed. If no error has occurred, the <code>callback</code> should be run without arguments or with an explicit <code>null</code> argument.<tr><td><code>callback(err)</code><td><code>function</code><td><strong>required</strong><td>A callback which is called when all <code>iterator</code> functions have finished, or an error occurs.</table><hr><p><a name="map"></a></p><h3 id="-span-class-member-method-span-map-iterator-callback-"><span class="member">method</span> map(iterator, callback)</h3><p>Produces a new array of values by mapping each value in <code>collection</code> resource through the <code>iterator</code> function. The <code>iterator</code> is called with an item from <code>collection</code> and a callback for when it has finished processing. Each of these callback takes 2 arguments: an <code>error</code>, and the transformed item from <code>collection</code>. If <code>iterator</code> passes an error to his callback, the main <code>callback</code> (for the <code>map</code> function) is immediately called with the error.</p><p>Note, that since this function applies the <code>iterator</code> to each item in parallel, there is no guarantee that the <code>iterator</code> functions will complete in order. However, the results array will be in the same order as the original <code>collection</code> resource items.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><h4 id="usage">Usage</h4><pre><code class="lang-javascript">// assuming applications is a collection resource

function pluckAppName(application, cb) {
  cb(null, application.name);
}

applications.map(pluckAppName, function(err, results) {
  // results is now an array of name for each application
});</code></pre><h4 id="parameters">Parameters</h4><table class="table table-striped table-hover table-curved"><thead><tr><th>Parameter<th>Type<th>Presence<th>Description<th><tbody><tr><td><code>iterator(item, callback)</code><td><code>function</code><td><strong>required</strong><td>A function to apply to each item in <code>arr</code>. The iterator is passed a <code>callback(err, transformed)</code> which must be called once it has completed with an error (which can be <code>null</code>) and a transformed item.<tr><td><code>callback(err, results)</code><td><code>function</code><td><strong>required</strong><td>A callback which is called when all <code>iterator</code> functions have finished, or an error occurs. Results is an array of the transformed items from the <code>collection</code> resource.</table><hr><p><a name="mapSeries"></a></p><h3 id="-span-class-member-method-span-mapseries-iterator-callback-"><span class="member">method</span> mapSeries(iterator, callback)</h3><p>The same as <a href="collectionResource#map"><code>map</code></a>, only the <code>iterator</code> is applied to each item in <code>collection</code> resource in series. The next <code>iterator</code> is only called once the current one has completed. The results array will be in the same order as the original.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><hr><p><a name="mapLimit"></a></p><h3 id="-span-class-member-method-span-maplimit-limit-iterator-callback-"><span class="member">method</span> mapLimit(limit, iterator, callback)</h3><p>The same as <a href="collectionResource#map"><code>map</code></a>, only no more than <code>limit</code> <code>iterator</code>s will be simultaneously running at any time.</p><p>Note that the items are not processed in batches, so there is no guarantee that the first <code>limit</code> <code>iterator</code> functions will complete before any others are started.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><h4 id="usage">Usage</h4><pre><code class="lang-javascript">// assuming applications is a collection resource

function pluckAppName(application, cb) {
  cb(null, application.name);
}

applications.map(pluckAppName, function(err, results) {
  // results is now an array of name for each application
});</code></pre><h4 id="parameters">Parameters</h4><table class="table table-striped table-hover table-curved"><thead><tr><th>Parameter<th>Type<th>Presence<th>Description<th><tbody><tr><td><code>limit</code><td><code>Number</code><td><strong>required</strong><td>The maximum number of <code>iterator</code>s to run at any time.<tr><td><code>iterator(item, callback)</code><td><code>function</code><td><strong>required</strong><td>A function to apply to each item in <code>arr</code>. The iterator is passed a <code>callback(err, transformed)</code> which must be called once it has completed with an error (which can be <code>null</code>) and a transformed item.<tr><td><code>callback(err, results)</code><td><code>function</code><td><strong>required</strong><td>A callback which is called when all <code>iterator</code> functions have finished, or an error occurs. Results is an array of the transformed items from the <code>collection</code> resource.</table><hr><p><a name="select"></a> <a name="filter"></a></p><h3 id="-span-class-member-method-span-filter-iterator-callback-"><span class="member">method</span> filter(iterator, callback)</h3><p><strong>Alias:</strong> <code>select</code></p><p>Returns a new array of all the values in <code>collection</code> resource items which pass an async truth test. <em>The callback for each <code>iterator</code> call only accepts a single argument of <code>true</code> or <code>false</code>; it does not accept an error argument first!</em> This is in-line with the way node libraries work with truth tests like <code>fs.exists</code>. This operation is performed in parallel, but the results array will be in the same order as the original.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><h4 id="usage">Usage</h4><pre><code class="lang-javascript">// assuming applications is a collection resource

function isAppContainsTest (application, cb) {
  cb(/test/.test(application.name));
}

applications.filter(isAppContainsTest, function(results) {
  // results now equals an array of the existing files
});</code></pre><h4 id="parameters">Parameters</h4><table class="table table-striped table-hover table-curved"><thead><tr><th>Parameter<th>Type<th>Presence<th>Description<th><tbody><tr><td><code>iterator(item, callback)</code><td><code>function</code><td><strong>required</strong><td>A truth test to apply to each item in <code>arr</code>. The <code>iterator</code> is passed a <code>callback(truthValue)</code>, which must be called with a boolean argument once it has completed.<tr><td><code>callback(results)</code><td><code>function</code><td><strong>required</strong><td>A callback which is called after all the <code>iterator</code> functions have finished.</table><hr><p><a name="selectSeries"></a> <a name="filterSeries"></a></p><h3 id="-span-class-member-method-span-filterseries-iterator-callback-"><span class="member">method</span> filterSeries(iterator, callback)</h3><p><strong>Alias:</strong> <code>selectSeries</code></p><p>The same as <a href="collectionResource#filter"><code>filter</code></a> only the <code>iterator</code> is applied to each item in <code>collection</code> resource in series. The next <code>iterator</code> is only called once the current one has completed. The results array will be in the same order as the original.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><hr><p><a name="reject"></a></p><h3 id="-span-class-member-method-span-reject-iterator-callback-"><span class="member">method</span> reject(iterator, callback)</h3><p>The opposite of <a href="collectionResource#filter"><code>filter</code></a>. Removes values that pass an <code>async</code> truth test.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><hr><p><a name="rejectSeries"></a></p><h3 id="-span-class-member-method-span-rejectseries-iterator-callback-"><span class="member">method</span> rejectSeries(iterator, callback)</h3><p>The same as <a href="collectionResource#reject"><code>reject</code></a>, only the <code>iterator</code> is applied to each item in <code>arr</code> in series.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><hr><p><a name="reduce"></a></p><h3 id="-span-class-member-method-span-reduce-memo-iterator-callback-"><span class="member">method</span> reduce(memo, iterator, callback)</h3><p><strong>Aliases:</strong> <code>inject</code>, <code>foldl</code></p><p>Reduces <code>collection</code> resource items into a single value using an async <code>iterator</code> to return each successive step. <code>memo</code> is the initial state of the reduction. This function only operates in series.</p><p>For performance reasons, it may make sense to split a call to this function into a parallel <code>map</code>, and then use the normal <code>Array.prototype.reduce</code> on the results.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><h4 id="usage">Usage</h4><pre><code class="lang-javascript">// assuming applications is a collection resource

applications.reduce(0, function(memo, item, callback) {
  // pointless async:
  process.nextTick(function() {
      callback(null, memo++);
  });
}, function(err, result) {
  // result is now equal to the last value of memo, which is count of applications
});</code></pre><h4 id="parameters">Parameters</h4><table class="table table-striped table-hover table-curved"><thead><tr><th>Parameter<th>Type<th>Presence<th>Description<th><tbody><tr><td><code>memo</code><td><code>any</code><td><strong>required</strong><td>The initial state of the reduction.<tr><td><code>iterator(memo, item, callback)</code><td><code>function</code><td><strong>required</strong><td>A function applied to each item in the <code>collection</code> resource to produce the next step in the reduction. The <code>iterator</code> is passed a <code>callback(err, reduction)</code> which accepts an optional error as its first argument, and the state of the reduction as the second. If an error is passed to the callback, the reduction is stopped and the main <code>callback</code> is immediately called with the error.<tr><td><code>callback(err, results)</code><td><code>function</code><td><strong>required</strong><td>A callback which is called after all the <code>iterator</code> functions have finished. Result is the reduced value.</table><hr><p><a name="reduceRight"></a></p><h3 id="-span-class-member-method-span-reduceright-memo-iterator-callback-"><span class="member">method</span> reduceRight(memo, iterator, callback)</h3><p><strong>Alias:</strong> <code>foldr</code></p><p>Same as <a href="collectionResource#reduce"><code>reduce</code></a>, only operates on <code>collection</code> resource in reverse order.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><hr><p><a name="detect"></a></p><h3 id="-span-class-member-method-span-detect-iterator-callback-"><span class="member">method</span> detect(iterator, callback)</h3><p>Returns the first value in <code>collection</code> resource that passes an async truth test. The <code>iterator</code> is applied in parallel, meaning the first iterator to return <code>true</code> will fire the detect <code>callback</code> with that result. That means the result might not be the first item in the original <code>collection</code> resource (in terms of order) that passes the test.</p><p>If order within the original <code>collection</code> resource is important, then look at <a href="collectionResource#detectSeries"><code>detectSeries</code></a>.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><h4 id="usage">Usage</h4><pre><code class="lang-javascript">// assuming applications is a collection resource

function isAppNameInLowerCase(application, cb) {
  cb(application.name === application.name.toLowerCase());
}

applications.detect(isAppNameInLowerCase, function(result) {
  // result now equals the first application in the list that has name in lower case
});</code></pre><h4 id="parameters">Parameters</h4><table class="table table-striped table-hover table-curved"><thead><tr><th>Parameter<th>Type<th>Presence<th>Description<th><tbody><tr><td><code>iterator(item, callback)</code><td><code>function</code><td><strong>required</strong><td>A truth test to apply to each item in <code>collection</code> resource. The iterator is passed a <code>callback(truthValue)</code> which must be called with a boolean argument once it has completed.<tr><td><code>callback(results)</code><td><code>function</code><td><strong>required</strong><td>A callback which is called as soon as any iterator returns <code>true</code>, or after all the <code>iterator</code> functions have finished. Result will be the first item in the array that passes the truth test (iterator) or the value <code>undefined</code> if none passed.</table><hr><p><a name="detectSeries"></a></p><h3 id="-span-class-member-method-span-detectseries-iterator-callback-"><span class="member">method</span> detectSeries(iterator, callback)</h3><p>The same as <a href="collectionResource#detect"><code>detect</code></a>, only the <code>iterator</code> is applied to each item in <code>collection</code> resource in series. This means the result is always the first in the original <code>collection</code> resource (in terms of items order) that passes the truth test.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><hr><p><a name="sortBy"></a></p><h3 id="-span-class-member-method-span-sortby-iterator-callback-"><span class="member">method</span> sortBy(iterator, callback)</h3><p>Sorts a list by the results of running each <code>collection</code> resource value through an async <code>iterator</code>.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><h4 id="usage">Usage</h4><pre><code class="lang-javascript">// assuming applications is a collection resource

applications.sortBy(function(application, callback) {
  callback(null, application.name);
}, function(err, results) {
  // results is now the array of application sorted by
  // application name
});</code></pre><p><strong>Sort Order</strong></p><p>By modifying the callback parameter the sorting order can be influenced:</p><pre><code class="lang-javascript">// case insensitive order
applications.sortBy(function(application, callback) {
  callback(err, application.name.toLowerCase());
}, function(err, result) {
  // result callback
} );

// case sensitive order
applications.sortBy(function(application, callback) {
    callback(null, application.name);
}, function(err, result) {
  // result callback
});</code></pre><h4 id="parameters">Parameters</h4><table class="table table-striped table-hover table-curved"><thead><tr><th>Parameter<th>Type<th>Presence<th>Description<th><tbody><tr><td><code>iterator(item, callback)</code><td><code>function</code><td><strong>required</strong><td>A function to apply to each item in <code>arr</code>. The iterator is passed a <code>callback(err, sortValue)</code> which must be called once it has completed with an error (which can be <code>null</code>) and a value to use as the sort criteria.<tr><td><code>callback(err, results)</code><td><code>function</code><td><strong>required</strong><td>A callback which is called after all the <code>iterator</code> functions have finished, or an error occurs. Results is the items from the original <code>arr</code> sorted by the values returned by the <code>iterator</code> calls.</table><hr><p><a name="some"></a></p><h3 id="-span-class-member-method-span-some-iterator-callback-"><span class="member">method</span> some(iterator, callback)</h3><p><strong>Alias:</strong> <code>any</code></p><p>Returns <code>true</code> if at least one element in the <code>collection</code> resource satisfies an async test. <em>The callback for each iterator call only accepts a single argument of <code>true</code> or <code>false</code>; it does not accept an error argument first!</em> This is in-line with the way node libraries work with truth tests like <code>fs.exists</code>. Once any iterator call returns <code>true</code>, the main <code>callback</code> is immediately called.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><h4 id="usage">Usage</h4><pre><code class="lang-javascript">// assuming applications is a collection resource

function isAppNameHasTest(application, cb) {
  cb(/test/.test(application.name));
}

applications.some(isAppNameHasTest, function(result) {
  // if result is true then at least one of the files exists
});</code></pre><h4 id="parameters">Parameters</h4><table class="table table-striped table-hover table-curved"><thead><tr><th>Parameter<th>Type<th>Presence<th>Description<th><tbody><tr><td><code>iterator(item, callback)</code><td><code>function</code><td><strong>required</strong><td>A truth test to apply to each item in the <code>collection</code> resource in parallel. The iterator is passed a callback(truthValue) which must be called with a boolean argument once it has completed.<tr><td><code>callback(results)</code><td><code>function</code><td><strong>required</strong><td>A callback which is called as soon as any iterator returns <code>true</code>, or after all the iterator functions have finished. Result will be either <code>true</code> or <code>false</code> depending on the values of the async tests.</table><hr><p><a name="every"></a></p><h3 id="-span-class-member-method-span-every-iterator-callback-"><span class="member">method</span> every(iterator, callback)</h3><p><strong>Alias:</strong> <code>all</code></p><p>Returns <code>true</code> if every element in <code>collection</code> resource satisfies an async test. <em>The callback for each <code>iterator</code> call only accepts a single argument of <code>true</code> or <code>false</code>; it does not accept an error argument first!</em> This is in-line with the way node libraries work with truth tests like <code>fs.exists</code>.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><h4 id="usage">Usage</h4><pre><code class="lang-javascript">// assuming applications is a collection resource

function isAppNameHasSecure(application, cb) {
  cb(/secure/.test(application.description);
}

applications.every(isAppNameHasSecure, function(result) {
  // if result is true then every application has &#39;secure&#39; word in description
});</code></pre><h4 id="parameters">Parameters</h4><table class="table table-striped table-hover table-curved"><thead><tr><th>Parameter<th>Type<th>Presence<th>Description<th><tbody><tr><td><code>iterator(item, callback)</code><td><code>function</code><td><strong>required</strong><td>A truth test to apply to each item in the array in parallel. The iterator is passed a callback(truthValue) which must be called with a boolean argument once it has completed.<tr><td><code>callback(results)</code><td><code>function</code><td><strong>required</strong><td>A callback which is called after all the <code>iterator</code> functions have finished. Result will be either <code>true</code> or <code>false</code> depending on the values of the async tests.</table><hr><p><a name="concat"></a></p><h3 id="-span-class-member-method-span-concat-iterator-callback-"><span class="member">method</span> concat(iterator, callback)</h3><p>Applies <code>iterator</code> to each item in <code>collection</code> resource, concatenating the results. Returns the concatenated list. The <code>iterator</code>s are called in parallel, and the results are concatenated as they return. There is no guarantee that the results array will be returned in the original order of <code>collection</code> resource items passed to the <code>iterator</code> function.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p><h4 id="usage">Usage</h4><pre><code class="lang-javascript">// assuming applications is a collection resource

function pluckAppNameAndHref(application, cb) {
  cb(null, { href: application.href, name: application.name });
}

applications.concat(pluckAppNameAndHref, function(err, apps) {
  // apps is now a list of app names and hrefs
});</code></pre><h4 id="parameters">Parameters</h4><table class="table table-striped table-hover table-curved"><thead><tr><th>Parameter<th>Type<th>Presence<th>Description<th><tbody><tr><td><code>iterator(item, callback)</code><td><code>function</code><td><strong>required</strong><td>A function to apply to each item in <code>arr</code>. The iterator is passed a <code>callback(err, results)</code> which must be called once it has completed with an error (which can be <code>null</code>) and an array of results.<tr><td><code>callback(err, results)</code><td><code>function</code><td><strong>required</strong><td>A callback which is called after all the <code>iterator</code><td>A callback which is called after all the <code>iterator</code> functions have finished, or an error occurs. Results is an array containing the concatenated results of the <code>iterator</code> function.</table><hr><p><a name="concatSeries"></a></p><h3 id="-span-class-member-method-span-concatseries-arr-iterator-callback-"><span class="member">method</span> concatSeries(arr, iterator, callback)</h3><p>Same as <a href="collectionResource#concat"><code>concat</code></a>, but executes in series instead of parallel.</p><p>Iterates (with automatic pagination - see above) over all resources within the collection.</p>
